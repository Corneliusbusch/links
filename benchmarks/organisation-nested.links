var db = database "organisation";

var departments = table "departments" with (dpt:String)
    		  tablekeys [["dpt"]] from db;
var employees = table "employees" with (emp:String, dpt:String, salary : Int) 
    	      	tablekeys [["emp"]] from db;
var tasks = table "tasks" with (id:Int,emp:String,tsk:String) 
    	  tablekeys [["id"]] from db;
var contacts = table "contacts" with (id:Int,name:String,dpt:String,"client":Bool) 
    	  tablekeys [["id"]] from db;

fun time(f) {
  var start = serverTimeMilliseconds();
  ignore(query {f()});
  var total = serverTimeMilliseconds()-start;
  print("Time: " ^^ intToString(total));
  total
}

fun throttle (f,x) {
  if (length(asList(departments)) <= 16) {f()} else {x}
}

# Supporting code


fun expertise_prime(u) {
  for (d <-- departments)
  where (empty( for (e <-- employees)
                where (d.dpt == e.dpt && 
		       empty( for (t <-- tasks)
		       	      where (e.emp == t.emp && t.tsk == u)
			      [()]))
		[()]))
  [(dpt=d.dpt)]
}


typename NestedOrg = [(dpt:String, 
                       employees: [(name:String,salary:Int,tasks:[String])],
		       contacts: [(name:String,"client":Bool)])];

sig nestedOrg : () -> NestedOrg
fun nestedOrg() {
  for (d <-- departments) 
  [(dpt=d.dpt, 
    employees= for (e <-- employees)
               where (d.dpt == e.dpt)
               [(name= e.emp, 
	         salary=e.salary,
	         tasks= for (t <-- tasks)
                      	where (e.emp == t.emp)
			[t.tsk])],
    contacts= for(y <-- contacts)
              where (d.dpt==y.dpt)
              [(name=y.name,"client"=y."client")])]
}

fun tasksOfEmployee(e) {
  for(t <-- tasks)
  where(e.emp == t.emp)
  [t.tsk]
}

fun contactsOfDepartment(d) {
  for(y <-- contacts)
  where (d.dpt==y.dpt)
  [(name=y.name,"client"=y."client")]
}

fun employeesOfDepartment(d) {
  for (e <-- employees)
  where (d.dpt == e.dpt)
  [(emp=e.emp,
    tasks= tasksOfEmployee(e))]
}

fun nestedOrgFactored() {
  query {
  for (d <-- departments) 
  [(dpt=d.dpt,
    employees=employeesOfDepartment(d),
    contacts=contactsOfDepartment(d))]
  }
}

sig any : ([a],(a) -a-> Bool) -a-> Bool
fun any(xs,p) {
  not(empty(for (x <- xs) where (p(x)) [()]))
}

sig all : ([a],(a) -a-> Bool) -a-> Bool
fun all(xs,p) {
  not(any(xs,fun (x) {not(p(x))}))
}

sig contains : ([a],a) -> Bool
fun contains(xs,u) {
  any(xs,fun (x) {x==u})
}

fun expertise(nestedOrg,u) {
  for (d <- nestedOrg)
  where (all(d.employees, 
   	     fun (e) {contains(e.tasks,u)}))
  [(dpt=d.dpt)]
} 

fun outliersQ() {
  for (x <-- departments)
  [(department=x.dpt,
    people=(for (y <-- employees)
           where(x.dpt == y.dpt && (y.salary < 1000 || y.salary > 1000000))
           [(name=y.emp,
             tasks=for(z <-- tasks)
                    where(z.emp == y.emp)
                    [z.tsk])])
           ++
           (for (y <-- contacts)
            where (x.dpt == y.dpt && y."client")
            [(name=y.dpt,tasks=["buy"])]))]
}

fun isPoor(x) {x.salary < 1000}
fun isRich(x) {x.salary > 1000000}
fun filter(p,xs) {for(x <- xs) where (p(x)) [x]}
fun get(xs,f) {for(x <- xs) [(name=x.name,tasks=f(x))]}
fun outliers(xs) {filter (fun (x) {isRich(x) || isPoor(x)},xs)}
fun clients(xs) {filter (fun (x) {x."client"},xs)}

fun outliersQFactored(organisation) {
  query {
    for (x <- organisation)
    [(department=x.dpt,
      people=get(outliers(x.employees), fun (y) {y.tasks}) ++ 
             get(clients(x.contacts), fun (y) {["buy"]}))]
  }
}


# Q1: nestedOrg (factored)

var x = print("\nQ1\n");

var q1 = throttle(fun () {time (nestedOrgFactored)},-1);
var q1 = throttle(fun () {time (nestedOrgFactored)},-1);

# Q2: expertise (factored)

var x = print("\nQ2\n");

var q2 = time (fun () {query {expertise(nestedOrg(),"abstract")}});
var q2 = time (fun () {query {expertise(nestedOrg(),"abstract")}});

# Q3: employees with lists of tasks
var x = print("\nQ3\n");

fun tasksByEmployee() {
  query {
    for(e <-- employees) 
    [(emp=(e.emp),b=tasksOfEmployee(e))]
  }
}

var q3 = time (tasksByEmployee);
var q3 = time (tasksByEmployee);

# Q4: departments with lists of employees

var x = print("\nQ4\n");

fun query4() {
  query {
    for(d <-- departments) 
    [(dpt=(d.dpt),emps=for (e <-- employees) where ((d.dpt) == (e.dpt)) [(e.emp)])]
  }
}

var q4 = time (query4);
var q4 = time (query4);

# Q5: Tasks with employees and departments

fun employeesByTask(t) {
  for(e <-- employees, d <-- departments)
  	       where (e.emp == t.emp && e.dpt == d.dpt)
	       [(b=e.emp, c=d.dpt)]
}

fun query5() {
  for(t <-- tasks)
  [(a=t.tsk, b=employeesByTask(t))]
}

var x = print("\nQ5\n");

var q5 =  time (fun () {query {query5()}});
var q5 =  time (fun () {query {query5()}});


# Q6: shredding paper example (factored)

var x = print("\nQ6\n");

var q6 =  throttle(fun () {time (fun () {query {outliersQFactored(nestedOrg())}})},-1);
var q6 =  throttle(fun () {time (fun () {query {outliersQFactored(nestedOrg())}})},-1);





var x = print("Q1:\t" ^^ (intToString(q1)) );
var x = print("Q2:\t" ^^ (intToString(q2)) );
var x = print("Q3:\t" ^^ (intToString(q3)) );
var x = print("Q4:\t" ^^ (intToString(q4)) );
var x = print("Q5:\t" ^^ (intToString(q5)) );
var x = print("Q6:\t" ^^ (intToString(q6)) );
()

