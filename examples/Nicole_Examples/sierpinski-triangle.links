typename Canvas = ();
typename Point = (x:Int, y:Int);
typename Dot = (point: Point, size: Int, text: String, hover: Bool);

alien javascript "/js/canvas.js" {
    getValueFromSelection: (String) ~> String;
    setBorderOfRef: (DomNode, String) ~> (DomNode);
}

alien javascript "js/runtime.js" {
    delayExecution: (Int) ~> ();
    setIntervalForF: (Int, () ~> ()) ~> Int;
    sysEnqueue: (a) ~> ();
    sysDequeue: () ~> [a];
    sysQueueLength: () -> Int;
}

typename Queue(a) = (rear: [a], front: [a]);
typename Option(a) = [|Some:a|None|];
typename PrioQueue(a) = (high: Queue(a), low: Queue(a));
typename Priority = [|High|Low|];
typename Co(e::Eff) = () {Fork: (Co({ |e}), Priority) -> (), Yield |e}~> ();
typename Time = Int;
typename Inteval = ();
typename Fiber0(e::Eff) = (prio: Priority, f: () {Fork: (Fiber0({ |e})) -> (), Yield |e}~> ());
typename SchedulerState(a) = (runQ: PrioQueue(a), prio: Priority, startTime: Time);
typename Fiber(e::Eff) = (prio:Priority, f: (SchedulerState(Fiber({ |e}))) ~e~> ());
typename FiberQueue(e::Eff) = PrioQueue(Fiber({ |e}));
typename Update = [|TextUpdate: String | LocationUpdate: Float|];
typename STriangle(e::Eff) = (point: Point, targetSize: Int, text: String, children: [STriangle({ |e})]);

var dotSize = 20;

#Threading 

sig enqueue: (a, Queue(a)) -> Queue(a)
fun enqueue(x, q){
    (q with rear=x::q.rear)
}

sig dequeue: (Queue(a)) ~> (Option(a), Queue(a))
fun dequeue(q){
    switch(q) {
        case (rear=[], front=[]) -> (None, q)
        case (rear=xs, front=[]) ->
          var q0 = (rear=[], front=reverse(xs));
          dequeue(q0)
        case (rear=ys, front=(x :: xs)) ->
          var q0 = (rear=ys, front=xs);
          (Some(x), q0)
    }
}

#priorityEnqueue : ( (priority:Priority |r), PriorityQueue({ priority:Priority |r}) ) -> PriorityQueue({ priority:Priority |r})
sig priorityEnqueue: (a, Priority, PrioQueue(a)) ~> PrioQueue(a)
fun priorityEnqueue(x, prio, pq){
    switch(prio){
        case High -> (pq with high = enqueue(x, pq.high))
        case Low -> (pq with low = enqueue(x, pq.low))
    }
}

sig priorityDequeue: (PrioQueue(a)) ~> (Option((a, Priority)), PrioQueue(a) )
fun priorityDequeue(pq){
    switch(dequeue(pq.high)){
        case (Some(x), q) -> (Some((x, High)), (pq with high= q))
        case (None,_) -> 
            switch(dequeue(pq.low)){
                case (None, _) -> (None, pq)
                case (Some(x), q) -> (Some((x, Low)), (pq with low=q))
            }
    }
}

sig fiberEnqueue: (Fiber({ |e}), FiberQueue({ |e})) ~> FiberQueue({ |e})
fun fiberEnqueue(f, q){
    priorityEnqueue(f, f.prio, q)
}

sig fiberBulkEnqueue: ([Fiber({ |e})], FiberQueue({ |e})) ~> FiberQueue({ |e})
fun fiberBulkEnqueue(fibers, q){
    switch(fibers){
        case [] -> q
        case x::xs -> 
            var pq = fiberEnqueue(x, q); 
            fiberBulkEnqueue(xs, pq)
    }
}

sig fiberDequeue: (FiberQueue({ |e})) ~> (Option((Fiber({ |e}), Priority)), FiberQueue({ |e}))
fun fiberDequeue(q){
    priorityDequeue(q)
}

fun emptyQueue(){
    (rear=[], front=[])
}

fun emptyPrioQueue(){
    (high= emptyQueue(), low=emptyQueue())
}

sig queueLength: (Queue(a)) -> Int
fun queueLength(q){
    length(q.rear) + length(q.front)
}

sig fiberQueueLength: (FiberQueue({ |e}))  -> Int
fun fiberQueueLength(q){
    length(q.low.rear) + length(q.high.front) + length(q.high.rear) + length(q.low.front)
}

sig addIntervalToList: (Int) ~> ()
fun addIntervalToList(id){
    
}

sig fork : (Fiber0({ |e})) {Fork: (Fiber0({ |e})) -> (), Yield |e}~> ()
fun fork(f){
    do Fork(f)
}

sig yield: () {Yield |e}~> ()
fun yield(){
    do Yield
}

sig makeFiber: (Priority, () {Fork: (Fiber0({ |e})) -> (), Yield |e}~> ()) -> Fiber0({ |e})
fun makeFiber(prio, f){
    (prio= prio, f=f)
}

sig forever: () {Yield |e}~> ()
fun forever(){ yield(); forever()}

sig schedule: (Fiber0({ |e})) {Yield-, Fork- | e}~> ()
fun schedule(main){

    fun runNext(q){
        switch(fiberDequeue(q)){
            case (None, _) -> ()
            case (Some((fiber, prio)), q) -> fiber.f(makeSchedulerState(prio, q))
        }
    }

    fun runFiber(fiber, runQ){
        #println("runQ: " ^^ intToString(fiberQueueLength(runQ)));
        #dump(self());
        handle(fiber.f()) ( (prio=fiber.prio, runQ=runQ, startTime=clientTime()) -> state){
            case Return(x) -> 
                runNext(poll(state.runQ))
            case Fork(f, resume) -> 
                var q = poll(state.runQ);
                switch ((f.prio, state.prio)) {
                    case (High, _) ->
                        var qq = fiberEnqueue(resumptionToFiber(resume, state.prio), q);
                        runFiber(f, qq)
                    case (_, High) ->
                        var qq = fiberEnqueue(fiber0ToFiber(f), q);
                        resume((), (state with runQ = qq))
                    case (_,_) ->
                        var qq = fiberEnqueue(resumptionToFiber(resume, state.prio), q);
                        runFiber(f, qq)
                }
            case Yield(resume) -> 
                var currentTime = clientTime();
                var buffer = switch(state.prio){
                    case High -> 2000
                    case Low -> 300 
                };
                if (currentTime - state.startTime <= buffer) resume((), state)
                else{
                    var q = fiberEnqueue(resumptionToFiber(resume, state.prio), state.runQ); 
                    runNext(poll(q))
                }
        }
    }

    #sig makeSchedulerState: (Priority, PrioQueue(a)) ~> SchedulerState(a)
    fun makeSchedulerState(prio, q){
        (runQ = q, prio = prio, startTime = clientTime())
    }

    #sig fiber0ToFiber: (Fiber0({ |%e})) ~%~> Fiber({ |%e})
    fun fiber0ToFiber(fiber){
        (prio = fiber.prio, f = fun(state) { runFiber(fiber, state.runQ ) })
    }

    fun resumptionToFiber(resume, prio){
        (prio = prio, f = fun(state) { resume((), state) })
    }

    #sig poll: (FiberQueue({ |e})) ~> FiberQueue({ |e})
    fun poll(q){
        var enqueue = map(fiber0ToFiber, sysDequeue());
        fiberBulkEnqueue(enqueue, q)
    }

    runFiber(main, emptyPrioQueue())

}


# Page Functionality

sig difference: (Point, Point) -> Point
fun difference(a, b){
    (x = a.x - b.x, y= a.y - b.y)
}

sig absolute: (Int) -> Int
fun absolute(n){
    if(n < 0){
        n * -1
    } else{
        n
    }
}

sig parseInt: (String) ~> Option(Int)
fun parseInt(n){ 
    if (n =~ /^[0-9]+$/) {
        Some(stringToInt(n))
    } else{
        None
    }
}

sig setValue: (a, String, (a) ~> String) ~%~> ()
fun setValue(newVal, id, toString){
    ignore(domSetAttributeFromRef(getNodeById(id), "value", toString(newVal)))
}

sig getValue: (String) ~> String
fun getValue(id){
    domGetAttributeFromRef(getNodeById(id), "value")
}

sig singleSTriangleToDot: (STriangle({ |e})) -> Dot
fun singleSTriangleToDot(triangle){
    (point = triangle.point, size = dotSize, text = triangle.text, hover = false )
}

sig makeSTriangle: (Point, Int, String, [STriangle({ |e})]) -> STriangle({ |e})
fun makeSTriangle(p, s, text, children){
    (point = p, targetSize = s, text=text, children=children)
}

sig getCircleStyleAttributeString: (Dot, (Float, Float, Float)) -> String
fun getCircleStyleAttributeString(dot, scale){
    var s = dotSize;
    var color ={ if(dot.hover) "#ff0" 
                else "#61dafb"
    };

    (" width: " ^^ intToString(s) ^^ "px; " ^^
    " height: " ^^ intToString(s) ^^ "px; " ^^
    " left: " ^^ intToString(dot.point.x) ^^ "px;" ^^
    " top: " ^^ intToString(dot.point.y) ^^ "px;" ^^ 
    " border-radius: " ^^ intToString(s/2) ^^ "px;" ^^
    " transform: scaleX(" ^^ floatToString(scale.1) ^^") scaleY(" ^^ floatToString(scale.2) ^^ ") translateZ(" ^^ floatToString(scale.3) ^^ ")" ^^
    " background-color: " ^^ color ^^";")     
}

sig dotToXml: (Dot, (Float, Float, Float)) ~%~> Xml
fun dotToXml(dot, scale){
    var style = getCircleStyleAttributeString(dot, scale);
    <#><div class="containerStyle"><div class="circle" style="{style}"><span>{stringToXml(dot.text)}</span></div></div></#>
    #addAttributes(div, [("style", style)])
}

sig drawDot: (Dot, DomNode, (Float, Float, Float)) ~> ()
fun drawDot(dot, node, scale){
    var xml = dotToXml(dot, scale);
    appendChildren(xml, node)
}

fun drawScaledTriangle(triangle, node, scale){
    switch(triangle.children){
        case [] -> drawDot(singleSTriangleToDot(triangle), node, scale)
        case x::y::z::xs -> drawScaledTriangle(x, node, scale); drawScaledTriangle(y, node, scale); drawScaledTriangle(z, node, scale)
    } 
}

sig drawTriangle: (STriangle({ |e}), DomNode) ~> ()
fun drawTriangle(triangle, node){    
    #println("draw Triangle");
    drawScaledTriangle(triangle, node, (1.0, 1.0, 1.0))
}

sig setUpTriangle: (Int, String) ~%~> Option(STriangle({ |e}))
fun setUpTriangle(s, text){
    if (s >= dotSize){
        fun getChildren(point, size){
            var x = point.x;
            var y = point.y;
            var newS = size/2;
            if (size >= dotSize) {
                [
                    makeSTriangle( (x = x, y = y - newS/2), newS, text, getChildren((x = x, y = y - newS/2), newS)), 
                    makeSTriangle( (x = x - newS, y = y + newS/2), newS, text, getChildren((x = x - newS, y = y + newS/2), newS)), 
                    makeSTriangle( (x = x + newS, y = y + newS/2), newS, text, getChildren((x = x + newS, y = y + newS/2), newS))
                ]
            }
            else []
        }
        Some(makeSTriangle((x = 0, y = 0), s, "", getChildren((x = 0, y = 0), s)))
    } 
    else None
    
}

sig calculateScale: (Int) ~> %
fun calculateScale(startTime){
    var elapsed = clientTime() - startTime;
    #println("elapsed: " ^^ intToString(elapsed));
    var t = elapsed `mod` 10;
    var w = {
        if(t > 5) 10 - t
        else t
    };
    var scale = (1.0 +. intToFloat(w)) /. 10.0;
    #println("w: "^^ intToString(w) ^^ " t: " ^^ intToString(t) ^^ " scale: " ^^ floatToString(scale));
    (1.0 +. scale /. 2.1, 0.7, 0.1)
}   

fun scaleDiv(node, startTime){
    #println("Scale Div");
    #println("startTime " ^^ intToString(startTime));
    var (x, y, z) = calculateScale(startTime);
    #var (x,y,z) = (3.0, 0.7, 0.1);
    var style = "scaleX(" ^^ floatToString(x); #^^"); scaleY(" ^^ floatToString(y)^^ ")"; #translateZ(" ^^ floatToString(z) ^^")
    #println(style);
    domSetStyleAttrFromRef(node, "transform", style)
    #domSetStyleAttrFromRef(node, "border", "solid 3px red")
}


fun giveBorderToChildren(id){
    var children = domGetChildrenFromRef(getNodeById(id));
    #println("number of children in ctnr: " ^^ intToString(length(children)));
    fun aux(xs){
        switch(xs){
            case [] -> ()
            case x::xs -> dump(setBorderOfRef(x, "solid 1px red;")); aux(xs)
        }
    }
    aux(children)
}

fun updateTriangle(triangle, startTime){
    #println("Update Triangle");
    scaleDiv(getNodeById("container"), startTime);
    domReplaceChildren( <#></#>, getNodeById("container"));
    drawTriangle(triangle, getNodeById("container"))
}

fun prepareUpdateFunction(triangle, startTime){
    fun (){
        updateTriangle(triangle, startTime)
    }
}

fun start(){
    fork(makeFiber(Low, forever));
    var tri = setUpTriangle(100, "1");
    var startTime = clientTime();
    switch(tri){
        case None -> ()
        case Some(triangle) -> 
            drawTriangle(triangle, getNodeById("container"));
            #delayExecution(2000);
            ignore(setIntervalForF(1000, fun() { 
                sysEnqueue(makeFiber(High, prepareUpdateFunction(triangle, startTime)))
            }))
    }
    
}

# Web interface

sig main_page : (_) ~> Page
fun main_page(_){

    var pId = spawnClient{schedule(makeFiber(High, start))};

    page
    <html>
    <head>
        <style>
        .center{{
            margin: 0 auto;
        }}
        .block{{
            display: block;
        }}
        .box{{
            width: 1400px;
            height: 800px;
            position: relative;
            /*border: 2px solid  #c4c4c4;*/
        }}
        .circle{{
            position: absolute;
            background-color: #61dafb;
            font: normal 15px sans-serif;
            text-align: center;
            display: block;
        }}
        .containerStyle {{
            position: absolute;
            transform-origin: 0 0;
            left: 50%;
            top: 50%;
            display: block;
            /*width: 50px;
            height: 50px;*/
        }}
        </style>
    </head>
    <body>
        <div id="container" class="box center">
        </div>
    </body>
    </html>
}

sig main: () ~> ()
fun main() {
    addRoute("/", main_page);
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    
    servePages()
}

main()